STUDY BUDDY AI - EXAM-SPECIFIC TRANSFORMATION GUIDE
====================================================

TRANSFORMATION GOAL
==================
Convert the general question-answering app into a specialized exam preparation tool 
for IIT JEE, NEET, SSC CGL, and UPSC with subject-specific question generation.

OVERVIEW OF CHANGES
===================
1. Add exam selection functionality
2. Add subject selection based on chosen exam
3. Modify question generation to be exam-specific
4. Update UI to reflect exam-specific interface
5. Add exam-specific difficulty levels
6. Enhance question templates for each exam type

CHRONOLOGICAL IMPLEMENTATION STEPS
==================================

PHASE 1: DATA STRUCTURE CHANGES
===============================

STEP 1: Create Exam Configuration File
--------------------------------------
FILE TO CREATE: src/config/exam_config.py

WHY: We need to define the structure of exams, subjects, and their relationships 
in a centralized way. This makes it easy to add new exams or modify existing ones.

WHAT TO DO:
1. Create a new file src/config/exam_config.py
2. Define exam data structure with subjects and topics for each exam
3. Include difficulty levels specific to each exam
4. Add question types available for each exam

EXAMPLE STRUCTURE:
```python
EXAM_CONFIG = {
    "IIT JEE": {
        "subjects": ["Physics", "Chemistry", "Mathematics"],
        "difficulty_levels": ["Easy", "Medium", "Hard", "Advanced"],
        "question_types": ["MCQ", "Fill in the Blank", "Numerical"],
        "topics": {
            "Physics": ["Mechanics", "Thermodynamics", "Optics", "Electromagnetism"],
            "Chemistry": ["Organic", "Inorganic", "Physical"],
            "Mathematics": ["Algebra", "Calculus", "Geometry", "Trigonometry"]
        }
    },
    "NEET": {
        "subjects": ["Physics", "Chemistry", "Biology"],
        "difficulty_levels": ["Easy", "Medium", "Hard"],
        "question_types": ["MCQ", "Fill in the Blank"],
        "topics": {
            "Physics": ["Mechanics", "Thermodynamics", "Optics", "Modern Physics"],
            "Chemistry": ["Organic", "Inorganic", "Physical"],
            "Biology": ["Botany", "Zoology", "Human Physiology"]
        }
    },
    "SSC CGL": {
        "subjects": ["Quantitative Aptitude", "General Intelligence", "English", "General Awareness"],
        "difficulty_levels": ["Easy", "Medium", "Hard"],
        "question_types": ["MCQ", "Fill in the Blank"],
        "topics": {
            "Quantitative Aptitude": ["Arithmetic", "Algebra", "Geometry", "Trigonometry"],
            "General Intelligence": ["Verbal", "Non-Verbal", "Logical"],
            "English": ["Grammar", "Vocabulary", "Comprehension"],
            "General Awareness": ["History", "Geography", "Science", "Current Affairs"]
        }
    },
    "UPSC": {
        "subjects": ["General Studies", "Optional Subject"],
        "difficulty_levels": ["Easy", "Medium", "Hard", "Expert"],
        "question_types": ["MCQ", "Fill in the Blank", "Descriptive"],
        "topics": {
            "General Studies": ["History", "Geography", "Polity", "Economy", "Science", "Environment"],
            "Optional Subject": ["Literature", "Public Administration", "Sociology", "Psychology"]
        }
    }
}
```

STEP 2: Update Question Schemas
-------------------------------
FILE TO MODIFY: src/models/question_schemas.py

WHY: We need to add exam-specific fields to our question models to track which 
exam, subject, and topic each question belongs to.

WHAT TO DO:
1. Add new fields to MCQQuestion and FillBlankQuestion classes:
   - exam: str
   - subject: str
   - topic: str
   - difficulty: str
2. Update field descriptions to be more specific
3. Add validation for exam-specific requirements

NEW FIELDS TO ADD:
```python
class MCQQuestion(BaseModel):
    exam: str = Field(description="The exam type (IIT JEE, NEET, etc.)")
    subject: str = Field(description="The subject within the exam")
    topic: str = Field(description="The specific topic within the subject")
    difficulty: str = Field(description="The difficulty level")
    question: str = Field(description="The question text")
    options: List[str] = Field(description="List of 4 options")
    correct_answer: str = Field(description="The correct answer")
    explanation: str = Field(description="Explanation for the answer")
```

PHASE 2: UI CHANGES
===================

STEP 3: Update Main Application Interface
-----------------------------------------
FILE TO MODIFY: application.py

WHY: We need to add exam and subject selection before question generation. The 
current interface only has topic input, but we need a hierarchical selection.

WHAT TO DO:
1. Add exam selection dropdown at the top
2. Add subject selection dropdown (populated based on exam choice)
3. Add topic selection dropdown (populated based on subject choice)
4. Update the sidebar layout to accommodate new selections
5. Modify the question generation call to pass exam, subject, and topic

NEW UI ELEMENTS TO ADD:
```python
# Add after st.title("Study Buddy AI")
st.subheader("Exam Preparation Tool")

# Exam selection
exam = st.selectbox(
    "Select Exam",
    ["IIT JEE", "NEET", "SSC CGL", "UPSC"],
    key="exam_selection"
)

# Subject selection (dynamic based on exam)
if exam:
    subjects = EXAM_CONFIG[exam]["subjects"]
    subject = st.selectbox(
        "Select Subject",
        subjects,
        key="subject_selection"
    )

# Topic selection (dynamic based on subject)
if subject:
    topics = EXAM_CONFIG[exam]["topics"][subject]
    topic = st.selectbox(
        "Select Topic",
        topics,
        key="topic_selection"
    )
```

STEP 4: Update Question Generation Interface
--------------------------------------------
FILE TO MODIFY: application.py (in the sidebar section)

WHY: We need to update the question generation interface to work with the new 
exam-specific structure and remove the generic topic input.

WHAT TO DO:
1. Remove the old topic text input
2. Update difficulty selection to use exam-specific levels
3. Update question type selection to use exam-specific types
4. Modify the generate button logic to pass exam, subject, topic

CHANGES TO MAKE:
```python
# Replace the old topic input with the new hierarchical selection
# Update difficulty selection
difficulty = st.selectbox(
    "Difficulty Level",
    EXAM_CONFIG[exam]["difficulty_levels"],
    index=1
)

# Update question type selection
question_type = st.selectbox(
    "Question Type",
    EXAM_CONFIG[exam]["question_types"],
    index=0
)
```

PHASE 3: BACKEND CHANGES
========================

STEP 5: Update Question Generator
---------------------------------
FILE TO MODIFY: src/generator/question_generator.py

WHY: We need to modify the question generation logic to create exam-specific 
questions with proper context and difficulty.

WHAT TO DO:
1. Update generate_mcq and generate_fill_blank methods to accept exam, subject, topic
2. Modify the prompt templates to include exam-specific context
3. Add exam-specific validation logic
4. Update the retry logic to handle exam-specific requirements

METHOD SIGNATURES TO CHANGE:
```python
def generate_mcq(self, exam: str, subject: str, topic: str, difficulty: str = "medium") -> MCQQuestion:
    # Implementation here

def generate_fill_blank(self, exam: str, subject: str, topic: str, difficulty: str = "medium") -> FillBlankQuestion:
    # Implementation here
```

STEP 6: Update Prompt Templates
-------------------------------
FILE TO MODIFY: src/prompts/templates.py

WHY: We need to create exam-specific prompt templates that generate questions 
appropriate for each exam type and difficulty level.

WHAT TO DO:
1. Create separate prompt templates for each exam
2. Add exam-specific instructions and examples
3. Include subject and topic context in prompts
4. Add difficulty-specific requirements

NEW TEMPLATE STRUCTURE:
```python
def get_mcq_prompt_template(exam: str, subject: str, topic: str, difficulty: str):
    base_template = f"""
    Generate a {difficulty} multiple-choice question for {exam} {subject} on the topic: {topic}.
    
    Exam-specific requirements:
    - Format: {EXAM_CONFIG[exam]['question_types']}
    - Difficulty: {difficulty}
    - Subject: {subject}
    - Topic: {topic}
    
    Return ONLY a JSON object with these exact fields:
    - 'exam': '{exam}'
    - 'subject': '{subject}'
    - 'topic': '{topic}'
    - 'difficulty': '{difficulty}'
    - 'question': A clear, specific question
    - 'options': An array of exactly 4 possible answers
    - 'correct_answer': One of the options that is correct
    - 'explanation': Brief explanation of why the answer is correct
    """
    return PromptTemplate(template=base_template, input_variables=[])
```

STEP 7: Update Quiz Manager
---------------------------
FILE TO MODIFY: src/utils/helpers.py

WHY: We need to update the QuizManager to handle exam-specific question generation 
and display.

WHAT TO DO:
1. Update generate_questions method to accept exam, subject, topic parameters
2. Modify question display to show exam-specific information
3. Update result evaluation to include exam-specific scoring
4. Add exam-specific question numbering and formatting

METHOD SIGNATURE TO CHANGE:
```python
def generate_questions(self, generator: QuestionGenerator, exam: str, subject: str, topic: str, question_type: str, difficulty: str, number_questions: int):
    # Implementation here
```

PHASE 4: ENHANCEMENTS
=====================

STEP 8: Add Exam-Specific Features
----------------------------------
FILES TO CREATE: src/features/

WHY: We need to add exam-specific features like time limits, scoring systems, 
and progress tracking.

WHAT TO DO:
1. Create exam-specific scoring systems
2. Add time limits for each exam type
3. Implement progress tracking
4. Add exam-specific analytics

NEW FILES TO CREATE:
- src/features/scoring.py
- src/features/timer.py
- src/features/progress.py
- src/features/analytics.py

STEP 9: Add Question Bank
-------------------------
FILE TO CREATE: src/data/question_bank.py

WHY: We need to store and manage a database of exam-specific questions for 
better question generation and variety.

WHAT TO DO:
1. Create a question bank structure
2. Add sample questions for each exam/subject/topic
3. Implement question selection logic
4. Add question difficulty calibration

STEP 10: Add Configuration Management
------------------------------------
FILE TO CREATE: src/config/settings.py

WHY: We need to manage exam-specific settings, API configurations, and 
application parameters in a centralized way.

WHAT TO DO:
1. Add exam-specific settings
2. Configure API parameters for each exam
3. Set up logging and monitoring
4. Add environment-specific configurations

PHASE 5: TESTING & VALIDATION
=============================

STEP 11: Add Unit Tests
-----------------------
FILE TO CREATE: tests/

WHY: We need to ensure that all exam-specific functionality works correctly 
and doesn't break existing features.

WHAT TO DO:
1. Create test files for each module
2. Add tests for exam-specific question generation
3. Test UI components with different exam selections
4. Add integration tests for the complete workflow

STEP 12: Add Validation
-----------------------
FILE TO MODIFY: src/utils/validation.py

WHY: We need to validate exam-specific inputs and ensure data integrity.

WHAT TO DO:
1. Add input validation for exam, subject, topic selections
2. Validate question generation parameters
3. Add data integrity checks
4. Implement error handling for invalid combinations

IMPLEMENTATION TIMELINE
=======================
- Phase 1 (Data Structure): 1-2 days
- Phase 2 (UI Changes): 2-3 days
- Phase 3 (Backend Changes): 3-4 days
- Phase 4 (Enhancements): 5-7 days
- Phase 5 (Testing): 2-3 days

Total Estimated Time: 2-3 weeks

TESTING CHECKLIST
=================
After each phase, test:
1. Exam selection works correctly
2. Subject selection updates based on exam
3. Topic selection updates based on subject
4. Question generation works for each exam type
5. UI displays correctly for all exam types
6. Question validation works properly
7. Results display correctly

COMMON PITFALLS TO AVOID
========================
1. Don't hardcode exam data in multiple places
2. Ensure all exam combinations are valid
3. Test with different difficulty levels
4. Validate all user inputs
5. Handle edge cases (empty selections, invalid combinations)
6. Maintain backward compatibility
7. Test performance with large question sets

FINAL NOTES
===========
- Start with Phase 1 and complete each phase before moving to the next
- Test thoroughly after each phase
- Keep the original functionality working while adding new features
- Document any changes you make
- Consider user feedback during development

This transformation will make your app much more valuable for exam preparation 
and provide a better user experience for students preparing for specific exams.
