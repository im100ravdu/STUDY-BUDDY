STUDY BUDDY AI - DETAILED EXAM TRANSFORMATION GUIDE
===================================================

This guide provides exact line numbers and code replacements for transforming 
your app into an exam-specific question generator.

PHASE 1: DATA STRUCTURE CHANGES
===============================

STEP 1: Create Exam Configuration File
--------------------------------------
FILE TO CREATE: src/config/exam_config.py

WHY: Centralized configuration for all exam data, subjects, and topics.

ACTION: Create new file with this exact content:

```python
EXAM_CONFIG = {
    "IIT JEE": {
        "subjects": ["Physics", "Chemistry", "Mathematics"],
        "difficulty_levels": ["Easy", "Medium", "Hard", "Advanced"],
        "question_types": ["MCQ", "Fill in the Blank", "Numerical"],
        "topics": {
            "Physics": ["Mechanics", "Thermodynamics", "Optics", "Electromagnetism", "Modern Physics"],
            "Chemistry": ["Organic Chemistry", "Inorganic Chemistry", "Physical Chemistry"],
            "Mathematics": ["Algebra", "Calculus", "Geometry", "Trigonometry", "Statistics"]
        }
    },
    "NEET": {
        "subjects": ["Physics", "Chemistry", "Biology"],
        "difficulty_levels": ["Easy", "Medium", "Hard"],
        "question_types": ["MCQ", "Fill in the Blank"],
        "topics": {
            "Physics": ["Mechanics", "Thermodynamics", "Optics", "Modern Physics", "Waves"],
            "Chemistry": ["Organic Chemistry", "Inorganic Chemistry", "Physical Chemistry"],
            "Biology": ["Botany", "Zoology", "Human Physiology", "Genetics", "Ecology"]
        }
    },
    "SSC CGL": {
        "subjects": ["Quantitative Aptitude", "General Intelligence", "English", "General Awareness"],
        "difficulty_levels": ["Easy", "Medium", "Hard"],
        "question_types": ["MCQ", "Fill in the Blank"],
        "topics": {
            "Quantitative Aptitude": ["Arithmetic", "Algebra", "Geometry", "Trigonometry", "Data Interpretation"],
            "General Intelligence": ["Verbal Reasoning", "Non-Verbal Reasoning", "Logical Reasoning"],
            "English": ["Grammar", "Vocabulary", "Comprehension", "Synonyms", "Antonyms"],
            "General Awareness": ["History", "Geography", "Science", "Current Affairs", "Polity"]
        }
    },
    "UPSC": {
        "subjects": ["General Studies", "Optional Subject"],
        "difficulty_levels": ["Easy", "Medium", "Hard", "Expert"],
        "question_types": ["MCQ", "Fill in the Blank", "Descriptive"],
        "topics": {
            "General Studies": ["History", "Geography", "Polity", "Economy", "Science", "Environment"],
            "Optional Subject": ["Literature", "Public Administration", "Sociology", "Psychology", "Philosophy"]
        }
    }
}
```

STEP 2: Update Question Schemas
-------------------------------
FILE TO MODIFY: src/models/question_schemas.py

WHY: Add exam-specific fields to track exam, subject, topic, and difficulty.

ACTION: Replace the entire file content with:

```python
from typing import List
from langchain_core.pydantic_v1 import BaseModel, Field, validator

class MCQQuestion(BaseModel):
    exam: str = Field(description="The exam type (IIT JEE, NEET, etc.)")
    subject: str = Field(description="The subject within the exam")
    topic: str = Field(description="The specific topic within the subject")
    difficulty: str = Field(description="The difficulty level")
    question: str = Field(description="The question text")
    options: List[str] = Field(description="List of 4 options")
    correct_answer: str = Field(description="The correct answer")
    explanation: str = Field(description="Explanation for the answer")

    @validator("question", pre=True, allow_reuse=True)
    def clean_mcq_question(cls, v):
        if isinstance(v, dict):
            return v.get("description", str(v))
        return str(v)
    
class FillBlankQuestion(BaseModel):
    exam: str = Field(description="The exam type (IIT JEE, NEET, etc.)")
    subject: str = Field(description="The subject within the exam")
    topic: str = Field(description="The specific topic within the subject")
    difficulty: str = Field(description="The difficulty level")
    question: str = Field(description="The question text with '___' for the blank")
    answer: str = Field(description="The correct word or phrase for the blank")
    explanation: str = Field(description="Explanation for the answer")

    @validator("question", pre=True, allow_reuse=True)
    def clean_fill_blank_question(cls, v):
        if isinstance(v, dict):
            return v.get("description", str(v))
        return str(v)
```

PHASE 2: UI CHANGES
===================

STEP 3: Update Main Application Interface
-----------------------------------------
FILE TO MODIFY: application.py

WHY: Add exam and subject selection before question generation.

ACTION: Make these specific changes:

1. **Line 1-6**: Add import for exam config
   REPLACE:
   ```python
   import os
   import streamlit as st
   from dotenv import load_dotenv
   from src.utils.helpers import *
   from src.generator.question_generator import QuestionGenerator
   load_dotenv()
   ```
   
   WITH:
   ```python
   import os
   import streamlit as st
   from dotenv import load_dotenv
   from src.utils.helpers import *
   from src.generator.question_generator import QuestionGenerator
   from src.config.exam_config import EXAM_CONFIG
   load_dotenv()
   ```

2. **Line 23**: Replace the title section
   REPLACE:
   ```python
   st.title("Study Buddy AI")
   ```
   
   WITH:
   ```python
   st.title("Study Buddy AI")
   st.subheader("Exam Preparation Tool")
   
   # Exam selection
   exam = st.selectbox(
       "Select Exam",
       ["IIT JEE", "NEET", "SSC CGL", "UPSC"],
       key="exam_selection"
   )
   
   # Subject selection (dynamic based on exam)
   if exam:
       subjects = EXAM_CONFIG[exam]["subjects"]
       subject = st.selectbox(
           "Select Subject",
           subjects,
           key="subject_selection"
       )
   
   # Topic selection (dynamic based on subject)
   if subject:
       topics = EXAM_CONFIG[exam]["topics"][subject]
       topic = st.selectbox(
           "Select Topic",
           topics,
           key="topic_selection"
       )
   ```

3. **Line 25-40**: Replace the sidebar section
   REPLACE:
   ```python
   st.sidebar.header("Quiz Settings")
   question_type = st.sidebar.selectbox(
   "Select Question Type",
   ["Multiple Choice", "Fill in the Blank"],
   index=0)

   topic = st.sidebar.text_input("Enter the topic",placeholder="Indian history, Geo")

   difficulty = st.sidebar.selectbox(
       "Difficulty Level",
       ["Easy","Medium","Hard"],
       index = 1)
   
   num_questions = st.sidebar.number_input("Number of questions user wants", min_value=1, max_value=10,
                                           value=5)
   ```
   
   WITH:
   ```python
   st.sidebar.header("Quiz Settings")
   
   # Only show quiz settings if exam, subject, and topic are selected
   if 'exam' in locals() and 'subject' in locals() and 'topic' in locals():
       question_type = st.sidebar.selectbox(
           "Select Question Type",
           EXAM_CONFIG[exam]["question_types"],
           index=0
       )

       difficulty = st.sidebar.selectbox(
           "Difficulty Level",
           EXAM_CONFIG[exam]["difficulty_levels"],
           index=1
       )
       
       num_questions = st.sidebar.number_input("Number of questions", min_value=1, max_value=10, value=5)
   ```

4. **Line 41-50**: Replace the generate quiz button section
   REPLACE:
   ```python
   if st.sidebar.button("Generate Quiz"):
       st.session_state.quiz_submitted = False
       generator = QuestionGenerator()
       success = st.session_state.quiz_manager.generate_questions(
           generator,
           topic,question_type,difficulty,num_questions
       )

       st.session_state.quiz_generated = success
       rerun()
   ```
   
   WITH:
   ```python
   if st.sidebar.button("Generate Quiz") and 'exam' in locals() and 'subject' in locals() and 'topic' in locals():
       st.session_state.quiz_submitted = False
       generator = QuestionGenerator()
       success = st.session_state.quiz_manager.generate_questions(
           generator,
           exam, subject, topic, question_type, difficulty, num_questions
       )

       st.session_state.quiz_generated = success
       rerun()
   else:
       if 'exam' not in locals() or 'subject' not in locals() or 'topic' not in locals():
           st.sidebar.warning("Please select exam, subject, and topic first")
   ```

PHASE 3: BACKEND CHANGES
========================

STEP 4: Update Question Generator
---------------------------------
FILE TO MODIFY: src/generator/question_generator.py

WHY: Modify question generation to accept exam-specific parameters.

ACTION: Make these specific changes:

1. **Line 1-7**: Add import for exam config
   REPLACE:
   ```python
   from langchain.output_parsers import PydanticOutputParser
   from src.models.question_schemas import MCQQuestion, FillBlankQuestion
   from src.prompts.templates import mcq_prompt_template, fill_blank_prompt_template
   from src.llm.groq_client import get_groq_llm
   from src.config.settings import settings
   from src.common.logger import get_logger
   from src.common.custom_exception import CustomException
   ```
   
   WITH:
   ```python
   from langchain.output_parsers import PydanticOutputParser
   from src.models.question_schemas import MCQQuestion, FillBlankQuestion
   from src.prompts.templates import get_mcq_prompt_template, get_fill_blank_prompt_template
   from src.llm.groq_client import get_groq_llm
   from src.config.settings import settings
   from src.common.logger import get_logger
   from src.common.custom_exception import CustomException
   ```

2. **Line 32-43**: Replace generate_mcq method
   REPLACE:
   ```python
   def generate_mcq(self,topic:str, difficulty:str="medium")-> MCQQuestion:
       try:
           parser = PydanticOutputParser(pydantic_object=MCQQuestion)
           question = self._retry_and_parse(mcq_prompt_template, parser, topic, difficulty)

           if len(question.options)!= 4 or question.correct_answer not in question.options:
               raise ValueError("Invalid MCQ Structure")
           self.logger.info("Generated a valid MCQ")
           return question
       except Exception as e:
           self.logger.error(f"Failed to generated MCQ: {str(e)}")
           raise CustomException("MCQ generation failed", e)
   ```
   
   WITH:
   ```python
   def generate_mcq(self, exam: str, subject: str, topic: str, difficulty: str = "medium") -> MCQQuestion:
       try:
           parser = PydanticOutputParser(pydantic_object=MCQQuestion)
           prompt_template = get_mcq_prompt_template(exam, subject, topic, difficulty)
           question = self._retry_and_parse(prompt_template, parser, exam, subject, topic, difficulty)

           if len(question.options) != 4 or question.correct_answer not in question.options:
               raise ValueError("Invalid MCQ Structure")
           self.logger.info("Generated a valid MCQ")
           return question
       except Exception as e:
           self.logger.error(f"Failed to generate MCQ: {str(e)}")
           raise CustomException("MCQ generation failed", e)
   ```

3. **Line 46-55**: Replace generate_fill_blank method
   REPLACE:
   ```python
   def generate_fill_blank(self,topic:str, difficulty:str="medium")-> FillBlankQuestion:
       try:
           parser = PydanticOutputParser(pydantic_object=FillBlankQuestion)
           question = self._retry_and_parse(fill_blank_prompt_template, parser, topic, difficulty)

           self.logger.info("Generated a valid fill in the blank")
           return question
       except Exception as e:
           self.logger.error(f"Failed to generated Fillups: {str(e)}")
           raise CustomException("Fill blank generation failed", e)
   ```
   
   WITH:
   ```python
   def generate_fill_blank(self, exam: str, subject: str, topic: str, difficulty: str = "medium") -> FillBlankQuestion:
       try:
           parser = PydanticOutputParser(pydantic_object=FillBlankQuestion)
           prompt_template = get_fill_blank_prompt_template(exam, subject, topic, difficulty)
           question = self._retry_and_parse(prompt_template, parser, exam, subject, topic, difficulty)

           self.logger.info("Generated a valid fill in the blank")
           return question
       except Exception as e:
           self.logger.error(f"Failed to generate Fill in the blank: {str(e)}")
           raise CustomException("Fill blank generation failed", e)
   ```

4. **Line 15-30**: Replace _retry_and_parse method
   REPLACE:
   ```python
   def _retry_and_parse(self, prompt, parser, topic, difficulty):

       for attempt in range(settings.MAX_RETRIES):
           try:
               self.logger.info(f"Generating question for topic {topic} with difficulty {difficulty}")
               response = self.llm.invoke(prompt.format(topic= topic, difficulty=difficulty))
               self.logger.info(f"LLM raw response: {response.content}")
               parsed = parser.parse(response.content)
               self.logger.info("successfully parsed the question")
               return parsed

           except Exception as e:
               self.logger.error(f"Error coming: f{str(e)}")
               if attempt==settings.MAX_RETRIES-1:
                   raise CustomException(f"Generation failed after {settings.MAX_RETRIES} attempts")
   ```
   
   WITH:
   ```python
   def _retry_and_parse(self, prompt, parser, exam, subject, topic, difficulty):
       for attempt in range(settings.MAX_RETRIES):
           try:
               self.logger.info(f"Generating question for {exam} {subject} - {topic} with difficulty {difficulty}")
               response = self.llm.invoke(prompt.format(exam=exam, subject=subject, topic=topic, difficulty=difficulty))
               self.logger.info(f"LLM raw response: {response.content}")
               parsed = parser.parse(response.content)
               self.logger.info("Successfully parsed the question")
               return parsed

           except Exception as e:
               self.logger.error(f"Error occurred: {str(e)}")
               if attempt == settings.MAX_RETRIES - 1:
                   raise CustomException(f"Generation failed after {settings.MAX_RETRIES} attempts")
   ```

STEP 5: Update Prompt Templates
-------------------------------
FILE TO MODIFY: src/prompts/templates.py

WHY: Create exam-specific prompt templates with proper context.

ACTION: Replace the entire file content with:

```python
from langchain_core.prompts import PromptTemplate
from src.config.exam_config import EXAM_CONFIG

def get_mcq_prompt_template(exam: str, subject: str, topic: str, difficulty: str):
    base_template = f"""
    Generate a {difficulty} multiple-choice question for {exam} {subject} on the topic: {topic}.
    
    Exam-specific requirements:
    - Exam: {exam}
    - Subject: {subject}
    - Topic: {topic}
    - Difficulty: {difficulty}
    - Question Type: Multiple Choice
    
    Return ONLY a JSON object with these exact fields:
    - 'exam': '{exam}'
    - 'subject': '{subject}'
    - 'topic': '{topic}'
    - 'difficulty': '{difficulty}'
    - 'question': A clear, specific question appropriate for {exam} level
    - 'options': An array of exactly 4 possible answers
    - 'correct_answer': One of the options that is correct
    - 'explanation': Brief explanation of why the answer is correct
    
    Example format:
    {{
        "exam": "{exam}",
        "subject": "{subject}",
        "topic": "{topic}",
        "difficulty": "{difficulty}",
        "question": "What is the capital of France?",
        "options": ["London", "Berlin", "Paris", "Madrid"],
        "correct_answer": "Paris",
        "explanation": "Paris is the capital and largest city of France."
    }}
    
    Your response:
    """
    return PromptTemplate(template=base_template, input_variables=[])

def get_fill_blank_prompt_template(exam: str, subject: str, topic: str, difficulty: str):
    base_template = f"""
    Generate a {difficulty} fill-in-the-blank question for {exam} {subject} on the topic: {topic}.
    
    Exam-specific requirements:
    - Exam: {exam}
    - Subject: {subject}
    - Topic: {topic}
    - Difficulty: {difficulty}
    - Question Type: Fill in the Blank
    
    Return ONLY a JSON object with these exact fields:
    - 'exam': '{exam}'
    - 'subject': '{subject}'
    - 'topic': '{topic}'
    - 'difficulty': '{difficulty}'
    - 'question': A sentence with '_____' marking where the blank should be
    - 'answer': The correct word or phrase that belongs in the blank
    - 'explanation': Brief explanation of why this answer is correct
    
    Example format:
    {{
        "exam": "{exam}",
        "subject": "{subject}",
        "topic": "{topic}",
        "difficulty": "{difficulty}",
        "question": "The capital of France is _____.",
        "answer": "Paris",
        "explanation": "Paris is the capital and largest city of France."
    }}
    
    Your response:
    """
    return PromptTemplate(template=base_template, input_variables=[])
```

STEP 6: Update Quiz Manager
---------------------------
FILE TO MODIFY: src/utils/helpers.py

WHY: Update QuizManager to handle exam-specific question generation.

ACTION: Make these specific changes:

1. **Line 15-43**: Replace generate_questions method
   REPLACE:
   ```python
   def generate_questions(self, generator:QuestionGenerator, topic:str , question_type:str, difficulty:str, number_questions:int):
       self.questions = []
       self.user_answers = []
       self.result = []

       try:
           for _ in range(number_questions):
               if question_type == "Multiple Choice":
                   question = generator.generate_mcq(topic, difficulty.lower())
                   
                   self.questions.append({
                       "type":"MCQ",
                       "question" : question.question,
                       "options" : question.options,
                       "correct_answer": question.correct_answer
                   })
               else:
                   question = generator.generate_fill_blank(topic, difficulty.lower())

                   self.questions.append({
                       "type":"Fill in the blank",
                       "question" : question.question,
                       "correct_answer": question.answer
                   })
       except Exception as e:
           st.error(f"Error generating question {e}")
           return False
       
       return True
   ```
   
   WITH:
   ```python
   def generate_questions(self, generator: QuestionGenerator, exam: str, subject: str, topic: str, question_type: str, difficulty: str, number_questions: int):
       self.questions = []
       self.user_answers = []
       self.result = []

       try:
           for _ in range(number_questions):
               if question_type == "MCQ":
                   question = generator.generate_mcq(exam, subject, topic, difficulty.lower())
                   
                   self.questions.append({
                       "type": "MCQ",
                       "exam": question.exam,
                       "subject": question.subject,
                       "topic": question.topic,
                       "difficulty": question.difficulty,
                       "question": question.question,
                       "options": question.options,
                       "correct_answer": question.correct_answer,
                       "explanation": question.explanation
                   })
               else:
                   question = generator.generate_fill_blank(exam, subject, topic, difficulty.lower())

                   self.questions.append({
                       "type": "Fill in the blank",
                       "exam": question.exam,
                       "subject": question.subject,
                       "topic": question.topic,
                       "difficulty": question.difficulty,
                       "question": question.question,
                       "correct_answer": question.answer,
                       "explanation": question.explanation
                   })
       except Exception as e:
           st.error(f"Error generating question {e}")
           return False
       
       return True
   ```

2. **Line 45-65**: Update attempt_quiz method to show exam info
   REPLACE:
   ```python
   def attempt_quiz(self):
       for i,q in enumerate(self.questions):
           st.markdown(f"**Question {i+1} : {q['question']}**")

           if q["type"] == "MCQ":
               user_answer = st.radio(f"Select an answer for question {i+1}",
                                     q["options"],
                                     key = f"mcq_{i}",
                                     index=None)  # No default selection
               if user_answer is not None:
                   if len(self.user_answers) <= i:
                       self.user_answers.extend([None] * (i - len(self.user_answers) + 1))
                   self.user_answers[i] = user_answer
           else:
               user_answer = st.text_input(
                   f"Fill in the blank for question{i+1}",
                   key = f"fill_blank{i}")
               
               if len(self.user_answers) <= i:
                   self.user_answers.extend([None] * (i - len(self.user_answers) + 1))
               self.user_answers[i] = user_answer
   ```
   
   WITH:
   ```python
   def attempt_quiz(self):
       for i,q in enumerate(self.questions):
           st.markdown(f"**Question {i+1}**")
           st.markdown(f"**Exam:** {q['exam']} | **Subject:** {q['subject']} | **Topic:** {q['topic']} | **Difficulty:** {q['difficulty']}")
           st.markdown(f"**Question:** {q['question']}")

           if q["type"] == "MCQ":
               user_answer = st.radio(f"Select an answer for question {i+1}",
                                     q["options"],
                                     key = f"mcq_{i}",
                                     index=None)  # No default selection
               if user_answer is not None:
                   if len(self.user_answers) <= i:
                       self.user_answers.extend([None] * (i - len(self.user_answers) + 1))
                   self.user_answers[i] = user_answer
           else:
               user_answer = st.text_input(
                   f"Fill in the blank for question {i+1}",
                   key = f"fill_blank{i}")
               
               if len(self.user_answers) <= i:
                   self.user_answers.extend([None] * (i - len(self.user_answers) + 1))
               self.user_answers[i] = user_answer
   ```

3. **Line 67-82**: Update evaluate_quiz method to include exam info
   REPLACE:
   ```python
   def evaluate_quiz(self):
       self.results = []

       for i, (q,user_ans) in enumerate(zip(self.questions,self.user_answers)):
           result_dict = {
               "question_number": i+1,
               "question": q["question"],
               "question_type": q["type"],
               "user_answer": user_ans,
               "correct_answer": q["correct_answer"],
               "is_correct": False
           }

           if q["type"] == "MCQ":
               result_dict["options"]=q["options"]
               result_dict["is_correct"] = user_ans == q["correct_answer"]

           else:
               result_dict["options"]= []
               result_dict["is_correct"] = user_ans.strip().lower() == q["correct_answer"].strip().lower()

           self.results.append(result_dict)
   ```
   
   WITH:
   ```python
   def evaluate_quiz(self):
       self.results = []

       for i, (q,user_ans) in enumerate(zip(self.questions,self.user_answers)):
           result_dict = {
               "question_number": i+1,
               "exam": q["exam"],
               "subject": q["subject"],
               "topic": q["topic"],
               "difficulty": q["difficulty"],
               "question": q["question"],
               "question_type": q["type"],
               "user_answer": user_ans,
               "correct_answer": q["correct_answer"],
               "explanation": q["explanation"],
               "is_correct": False
           }

           if q["type"] == "MCQ":
               result_dict["options"]=q["options"]
               result_dict["is_correct"] = user_ans == q["correct_answer"]

           else:
               result_dict["options"]= []
               result_dict["is_correct"] = user_ans.strip().lower() == q["correct_answer"].strip().lower()

           self.results.append(result_dict)
   ```

TESTING CHECKLIST
=================
After implementing all changes:

1. ✅ Test exam selection dropdown
2. ✅ Test subject selection updates based on exam
3. ✅ Test topic selection updates based on subject
4. ✅ Test question generation for each exam type
5. ✅ Test UI displays correctly for all exam types
6. ✅ Test question validation works properly
7. ✅ Test results display correctly with exam info

IMPLEMENTATION ORDER
===================
1. Create src/config/exam_config.py
2. Update src/models/question_schemas.py
3. Update application.py (UI changes)
4. Update src/generator/question_generator.py
5. Update src/prompts/templates.py
6. Update src/utils/helpers.py
7. Test all functionality

This detailed guide provides exact line numbers and code replacements for each modification needed.
